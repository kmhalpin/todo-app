// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"context"
	tModel "github.com/kmhalpin/todoapp/internal/model/todo"
	"github.com/kmhalpin/todoapp/internal/repository/todo"
	"sync"
)

// Ensure, that RepositoryMock does implement todo.Repository.
// If this is not the case, regenerate this file with moq.
var _ todo.Repository = &RepositoryMock{}

// RepositoryMock is a mock implementation of todo.Repository.
//
// 	func TestSomethingThatUsesRepository(t *testing.T) {
//
// 		// make and configure a mocked todo.Repository
// 		mockedRepository := &RepositoryMock{
// 			DeleteTodoFunc: func(ctx context.Context, id string) (string, error) {
// 				panic("mock out the DeleteTodo method")
// 			},
// 			GetTodoFunc: func(ctx context.Context) ([]tModel.Todo, error) {
// 				panic("mock out the GetTodo method")
// 			},
// 			GetTodoByIDFunc: func(ctx context.Context, id string) (tModel.Todo, error) {
// 				panic("mock out the GetTodoByID method")
// 			},
// 			InsertTodoFunc: func(ctx context.Context, todo tModel.Todo) (string, error) {
// 				panic("mock out the InsertTodo method")
// 			},
// 			UpdateTodoFunc: func(ctx context.Context, todo tModel.Todo) (string, error) {
// 				panic("mock out the UpdateTodo method")
// 			},
// 		}
//
// 		// use mockedRepository in code that requires todo.Repository
// 		// and then make assertions.
//
// 	}
type RepositoryMock struct {
	// DeleteTodoFunc mocks the DeleteTodo method.
	DeleteTodoFunc func(ctx context.Context, id string) (string, error)

	// GetTodoFunc mocks the GetTodo method.
	GetTodoFunc func(ctx context.Context) ([]tModel.Todo, error)

	// GetTodoByIDFunc mocks the GetTodoByID method.
	GetTodoByIDFunc func(ctx context.Context, id string) (tModel.Todo, error)

	// InsertTodoFunc mocks the InsertTodo method.
	InsertTodoFunc func(ctx context.Context, todo tModel.Todo) (string, error)

	// UpdateTodoFunc mocks the UpdateTodo method.
	UpdateTodoFunc func(ctx context.Context, todo tModel.Todo) (string, error)

	// calls tracks calls to the methods.
	calls struct {
		// DeleteTodo holds details about calls to the DeleteTodo method.
		DeleteTodo []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID string
		}
		// GetTodo holds details about calls to the GetTodo method.
		GetTodo []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// GetTodoByID holds details about calls to the GetTodoByID method.
		GetTodoByID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID string
		}
		// InsertTodo holds details about calls to the InsertTodo method.
		InsertTodo []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Todo is the todo argument value.
			Todo tModel.Todo
		}
		// UpdateTodo holds details about calls to the UpdateTodo method.
		UpdateTodo []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Todo is the todo argument value.
			Todo tModel.Todo
		}
	}
	lockDeleteTodo  sync.RWMutex
	lockGetTodo     sync.RWMutex
	lockGetTodoByID sync.RWMutex
	lockInsertTodo  sync.RWMutex
	lockUpdateTodo  sync.RWMutex
}

// DeleteTodo calls DeleteTodoFunc.
func (mock *RepositoryMock) DeleteTodo(ctx context.Context, id string) (string, error) {
	if mock.DeleteTodoFunc == nil {
		panic("RepositoryMock.DeleteTodoFunc: method is nil but Repository.DeleteTodo was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  string
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockDeleteTodo.Lock()
	mock.calls.DeleteTodo = append(mock.calls.DeleteTodo, callInfo)
	mock.lockDeleteTodo.Unlock()
	return mock.DeleteTodoFunc(ctx, id)
}

// DeleteTodoCalls gets all the calls that were made to DeleteTodo.
// Check the length with:
//     len(mockedRepository.DeleteTodoCalls())
func (mock *RepositoryMock) DeleteTodoCalls() []struct {
	Ctx context.Context
	ID  string
} {
	var calls []struct {
		Ctx context.Context
		ID  string
	}
	mock.lockDeleteTodo.RLock()
	calls = mock.calls.DeleteTodo
	mock.lockDeleteTodo.RUnlock()
	return calls
}

// GetTodo calls GetTodoFunc.
func (mock *RepositoryMock) GetTodo(ctx context.Context) ([]tModel.Todo, error) {
	if mock.GetTodoFunc == nil {
		panic("RepositoryMock.GetTodoFunc: method is nil but Repository.GetTodo was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetTodo.Lock()
	mock.calls.GetTodo = append(mock.calls.GetTodo, callInfo)
	mock.lockGetTodo.Unlock()
	return mock.GetTodoFunc(ctx)
}

// GetTodoCalls gets all the calls that were made to GetTodo.
// Check the length with:
//     len(mockedRepository.GetTodoCalls())
func (mock *RepositoryMock) GetTodoCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockGetTodo.RLock()
	calls = mock.calls.GetTodo
	mock.lockGetTodo.RUnlock()
	return calls
}

// GetTodoByID calls GetTodoByIDFunc.
func (mock *RepositoryMock) GetTodoByID(ctx context.Context, id string) (tModel.Todo, error) {
	if mock.GetTodoByIDFunc == nil {
		panic("RepositoryMock.GetTodoByIDFunc: method is nil but Repository.GetTodoByID was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  string
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGetTodoByID.Lock()
	mock.calls.GetTodoByID = append(mock.calls.GetTodoByID, callInfo)
	mock.lockGetTodoByID.Unlock()
	return mock.GetTodoByIDFunc(ctx, id)
}

// GetTodoByIDCalls gets all the calls that were made to GetTodoByID.
// Check the length with:
//     len(mockedRepository.GetTodoByIDCalls())
func (mock *RepositoryMock) GetTodoByIDCalls() []struct {
	Ctx context.Context
	ID  string
} {
	var calls []struct {
		Ctx context.Context
		ID  string
	}
	mock.lockGetTodoByID.RLock()
	calls = mock.calls.GetTodoByID
	mock.lockGetTodoByID.RUnlock()
	return calls
}

// InsertTodo calls InsertTodoFunc.
func (mock *RepositoryMock) InsertTodo(ctx context.Context, todo tModel.Todo) (string, error) {
	if mock.InsertTodoFunc == nil {
		panic("RepositoryMock.InsertTodoFunc: method is nil but Repository.InsertTodo was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Todo tModel.Todo
	}{
		Ctx:  ctx,
		Todo: todo,
	}
	mock.lockInsertTodo.Lock()
	mock.calls.InsertTodo = append(mock.calls.InsertTodo, callInfo)
	mock.lockInsertTodo.Unlock()
	return mock.InsertTodoFunc(ctx, todo)
}

// InsertTodoCalls gets all the calls that were made to InsertTodo.
// Check the length with:
//     len(mockedRepository.InsertTodoCalls())
func (mock *RepositoryMock) InsertTodoCalls() []struct {
	Ctx  context.Context
	Todo tModel.Todo
} {
	var calls []struct {
		Ctx  context.Context
		Todo tModel.Todo
	}
	mock.lockInsertTodo.RLock()
	calls = mock.calls.InsertTodo
	mock.lockInsertTodo.RUnlock()
	return calls
}

// UpdateTodo calls UpdateTodoFunc.
func (mock *RepositoryMock) UpdateTodo(ctx context.Context, todo tModel.Todo) (string, error) {
	if mock.UpdateTodoFunc == nil {
		panic("RepositoryMock.UpdateTodoFunc: method is nil but Repository.UpdateTodo was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Todo tModel.Todo
	}{
		Ctx:  ctx,
		Todo: todo,
	}
	mock.lockUpdateTodo.Lock()
	mock.calls.UpdateTodo = append(mock.calls.UpdateTodo, callInfo)
	mock.lockUpdateTodo.Unlock()
	return mock.UpdateTodoFunc(ctx, todo)
}

// UpdateTodoCalls gets all the calls that were made to UpdateTodo.
// Check the length with:
//     len(mockedRepository.UpdateTodoCalls())
func (mock *RepositoryMock) UpdateTodoCalls() []struct {
	Ctx  context.Context
	Todo tModel.Todo
} {
	var calls []struct {
		Ctx  context.Context
		Todo tModel.Todo
	}
	mock.lockUpdateTodo.RLock()
	calls = mock.calls.UpdateTodo
	mock.lockUpdateTodo.RUnlock()
	return calls
}
